/*
    Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
    Copyright (c) 2012 - 2022 Xilinx, Inc. All Rights Reserved.
	SPDX-License-Identifier: MIT


    http://www.FreeRTOS.org
    http://aws.amazon.com/freertos


    1 tab == 4 spaces!
*/

/* FreeRTOS includes. */
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
#include "timers.h"
/* Xilinx includes. */
#include "xil_printf.h"
#include "xparameters.h"
#include "xil_io.h"
typedef struct {
		 u32 	colorFormat;
		 u32 	bckgndId;
		 u32	width;
		 u32	height;
	} TpgConfig_t;

int system_init(XV_tpg* TpgInstPtr, XVtc* VtcInstPtr, XGpio* XGpioInstPtr);
void tpg_configuration(XV_tpg *InstPtr, TpgConfig_t *ConfigPtr);
void configure_vtc_gen(XVtc *InstancePtr, const XVidC_VideoStream *Strm);

#define TIMER_ID	1
#define DELAY_10_SECONDS	10000UL
#define DELAY_1_SECOND		1000UL
#define TIMER_CHECK_THRESHOLD	9
/*-----------------------------------------------------------*/

/* The Tx and Rx tasks as described at the top of this file. */
static void prvTxTask( void *pvParameters );
static void prvRxTask( void *pvParameters );
static void vTimerCallback( TimerHandle_t pxTimer );
/*-----------------------------------------------------------*/

/* The queue used by the Tx and Rx tasks, as described at the top of this
file. */
static TaskHandle_t xTxTask;
static TaskHandle_t xRxTask;
static QueueHandle_t xQueue = NULL;
static TimerHandle_t xTimer = NULL;
char HWstring[15] = "Hello World";
long RxtaskCntr = 0;

#if (configSUPPORT_STATIC_ALLOCATION == 1)
#define QUEUE_BUFFER_SIZE		100

uint8_t ucQueueStorageArea[ QUEUE_BUFFER_SIZE ];
StackType_t xStack1[ configMINIMAL_STACK_SIZE ];
StackType_t xStack2[ configMINIMAL_STACK_SIZE ];
StaticTask_t xTxBuffer,xRxBuffer;
StaticTimer_t xTimerBuffer;
static StaticQueue_t xStaticQueue;
#endif

int main( void )
{
	xil_printf( "Hello from Freertos example main\r\n" );

	//config
		Xil_Out32(XPAR_AXI_VDMA_0_BASEADDR + 0x30, 0x8B);
		//frame buffers
		//frame size is 3*1280*720 = 2A3000
		//margin on frame = 1000
		Xil_Out32(XPAR_AXI_VDMA_0_BASEADDR + 0xAC, 0x10000000);
		Xil_Out32(XPAR_AXI_VDMA_0_BASEADDR + 0xB0, 0x102A4000);//2A4000
		Xil_Out32(XPAR_AXI_VDMA_0_BASEADDR + 0xB4, 0x10548000);//2A4000
		//HSIZE
		Xil_Out32(XPAR_AXI_VDMA_0_BASEADDR + 0xA8, 1280*3);
		Xil_Out32(XPAR_AXI_VDMA_0_BASEADDR + 0xA4, 1280*3);
		//VSIZE
		Xil_Out32(XPAR_AXI_VDMA_0_BASEADDR + 0xA0, 720);

	//read
		Xil_Out32(XPAR_AXI_VDMA_0_BASEADDR + 0x00, 0x8B);
		Xil_Out32(XPAR_AXI_VDMA_0_BASEADDR + 0x5C, 0x10000000);
		Xil_Out32(XPAR_AXI_VDMA_0_BASEADDR + 0x60, 0x102A4000);
		Xil_Out32(XPAR_AXI_VDMA_0_BASEADDR + 0x64, 0x10548000);
		Xil_Out32(XPAR_AXI_VDMA_0_BASEADDR + 0x58, 1280*3);
		Xil_Out32(XPAR_AXI_VDMA_0_BASEADDR + 0x54, 1280*3);
		Xil_Out32(XPAR_AXI_VDMA_0_BASEADDR + 0x50, 720);

		xil_printf( "writing in video memory\r\n" );

	for( ;; );

}

int system_init(XV_tpg* TpgInstPtr, XVtc* VtcInstPtr, XGpio* XGpioInstPtr)
{
	int Status;

    // Initialise the TPG
    Status = XV_tpg_Initialize(TpgInstPtr, 0);
    if(Status!= XST_SUCCESS)
    {
    	xdbg_printf(XDBG_DEBUG_GENERAL,"TPG configuration failed\r\n");
        return(XST_FAILURE);
    }

    // Initialise the VTC
    XVtc_Config *VtcConfig = XVtc_LookupConfig(0);
    XVtc_CfgInitialize(VtcInstPtr, VtcConfig, VtcConfig->BaseAddress);
    if(Status!= XST_SUCCESS)
    {
    	xdbg_printf(XDBG_DEBUG_GENERAL,"VTC configuration failed\r\n");
        return(XST_FAILURE);
    }

	/* Initialize the GPIO driver */
	Status = XGpio_Initialize(XGpioInstPtr, 0);
	if (Status != XST_SUCCESS) {
		xil_printf("Gpio Initialization Failed\r\n");
		return XST_FAILURE;
	}


	return Status;
};

void tpg_configuration(XV_tpg *InstPtr, TpgConfig_t *ConfigPtr)
{
	// Set Resolution
    XV_tpg_Set_height(InstPtr, ConfigPtr->height);
    XV_tpg_Set_width(InstPtr, ConfigPtr->width);

    // Set Color Space
    XV_tpg_Set_colorFormat(InstPtr, ConfigPtr->colorFormat);

    //Set background
    XV_tpg_Set_bckgndId(InstPtr, ConfigPtr->bckgndId);

    XV_tpg_EnableAutoRestart(InstPtr);
    XV_tpg_Start(InstPtr);
};

/*****************************************************************************/
/**
*
* This function configures the VTC Generator core.
* @param
* @param
*
*
******************************************************************************/
void configure_vtc_gen(XVtc *InstancePtr, const XVidC_VideoStream *Strm)
{
	XVtc_Reset(InstancePtr);
	XVtc_DisableGenerator(InstancePtr);
	XVtc_Disable(InstancePtr);

	XVtc_Timing XVtc_Timingconf;

	XVtc_Timingconf.HActiveVideo 	= Strm->Timing.HActive;
	XVtc_Timingconf.HBackPorch		= Strm->Timing.HBackPorch;
	XVtc_Timingconf.HFrontPorch		= Strm->Timing.HFrontPorch;
	XVtc_Timingconf.HSyncPolarity	= Strm->Timing.HSyncPolarity;
	XVtc_Timingconf.HSyncWidth		= Strm->Timing.HSyncWidth;
	XVtc_Timingconf.Interlaced		= Strm->IsInterlaced;
	XVtc_Timingconf.V0BackPorch		= Strm->Timing.F0PVBackPorch;
	XVtc_Timingconf.V0FrontPorch	= Strm->Timing.F0PVFrontPorch;
	XVtc_Timingconf.V0SyncWidth		= Strm->Timing.F0PVSyncWidth;
	XVtc_Timingconf.V1BackPorch		= Strm->Timing.F1VBackPorch;
	XVtc_Timingconf.V1FrontPorch	= Strm->Timing.F1VFrontPorch;
	XVtc_Timingconf.V1SyncWidth		= Strm->Timing.F1VSyncWidth;
	XVtc_Timingconf.VActiveVideo	= Strm->Timing.VActive;
	XVtc_Timingconf.VSyncPolarity	= Strm->Timing.VSyncPolarity;

	//Configure the VTC
	XVtc_SetGeneratorTiming(InstancePtr, &XVtc_Timingconf);
	XVtc_RegUpdate(InstancePtr);

	//Start the VTC generator
	XVtc_Enable(InstancePtr);
	XVtc_EnableGenerator(InstancePtr);
}
